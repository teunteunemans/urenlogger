---
phase: 02-command-migration
plan: 01
type: execute
depends_on: []
files_modified:
  - next/package.json
  - next/lib/types.ts
  - next/lib/config/constants.ts
  - next/lib/i18n/nl.ts
  - next/lib/utils/dateParser.ts
  - next/lib/firebase/service.ts
  - next/lib/discord/commands.ts
  - next/app/api/interactions/route.ts
  - next/.env.example
domain: next-js
---

<objective>
Port shared modules and set up command dispatch infrastructure.

Purpose: Establish all shared utilities (types, config, i18n, date parser, Firebase service) and command routing so that Plan 02 can implement the actual commands.
Output: Working foundation with Firebase connected, date parsing available, i18n messages ready, and interaction endpoint dispatching commands by name.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-project-setup/01-01-SUMMARY.md

# Source files to port FROM (reference implementation):
@src/types.ts
@src/config/constants.ts
@src/i18n/nl.ts
@src/utils/dateParser.ts
@src/utils/firebaseService.ts

# Existing Next.js files to build on:
@next/app/api/interactions/route.ts
@next/lib/discord/verify.ts
@next/package.json
@next/.env.example

**Tech stack available:** Next.js 15, discord-verify, discord-api-types
**Established patterns:** API route handler, raw body signature verification, verify() from discord-verify/node
**Constraining decisions:**
- Phase 01: Used verify() from discord-verify/node (not isValidRequest)
- Phase 01: Node.js runtime set for all API routes (firebase-admin requirement)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port shared modules and install dependencies</name>
  <files>next/package.json, next/lib/types.ts, next/lib/config/constants.ts, next/lib/i18n/nl.ts, next/lib/utils/dateParser.ts, next/.env.example</files>
  <action>
Install dependencies in next/:
- firebase-admin (for Firestore)
- date-fns and date-fns-tz (for Dutch date parsing)
- nodemailer and @types/nodemailer (for email in Plan 02-02)

Port the following from src/ to next/lib/, adapting imports to use @/ path aliases:

1. **next/lib/types.ts** - Copy interfaces from src/types.ts (User, HourLog, BillingPeriod, UserHoursSummary, MonthlyReport). No discord.js types needed.

2. **next/lib/config/constants.ts** - Copy from src/config/constants.ts. Keep BILLING_PERIOD, DUTCH_MONTHS, DUTCH_MONTH_NAMES, DISCORD_MESSAGE_LIMIT, DISCORD_MESSAGE_SAFE_LIMIT. Remove REQUIRED_ENV_VARS and OPTIONAL_ENV_VARS (Vercel handles env validation). Remove discord.js-specific constants if any.

3. **next/lib/i18n/nl.ts** - Copy from src/i18n/nl.ts. Keep all messages and commandDescriptions objects unchanged. The messages are pure strings/functions with no discord.js dependency.

4. **next/lib/utils/dateParser.ts** - Copy from src/utils/dateParser.ts. All imports are date-fns and internal config — update import paths to use @/lib/config/constants and @/lib/types. No discord.js dependency to remove.

5. **next/.env.example** - Add Firebase and SMTP env vars to existing Discord vars:
   - GOOGLE_APPLICATION_CREDENTIALS (or FIREBASE_SERVICE_ACCOUNT for base64-encoded JSON — Vercel can't mount files, so the service account JSON must be passed as a base64-encoded string in an env var)
   - SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS
   - YOUR_EMAIL_ADDRESS, BOSS_EMAIL
   - LOG_CHANNEL_ID (optional)

Important: For Firebase on Vercel, the service account JSON must be passed as a base64-encoded env var (FIREBASE_SERVICE_ACCOUNT), not a file path. The Firebase service in Task 2 will handle decoding.
  </action>
  <verify>cd next && npm run build succeeds without errors. All new files exist and have correct imports.</verify>
  <done>All shared modules ported to next/lib/ with correct @/ imports. Dependencies installed. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Set up Firebase service and command dispatch router</name>
  <files>next/lib/firebase/service.ts, next/lib/discord/commands.ts, next/app/api/interactions/route.ts</files>
  <action>
1. **next/lib/firebase/service.ts** - Port from src/utils/firebaseService.ts with these changes:
   - Use base64-decoded service account from FIREBASE_SERVICE_ACCOUNT env var instead of file path (Vercel serverless can't mount files). Decode with `Buffer.from(process.env.FIREBASE_SERVICE_ACCOUNT!, "base64").toString("utf-8")` then JSON.parse.
   - Keep the singleton Promise pattern for initialization (prevents cold-start race conditions in serverless).
   - Port ALL functions: registerUser, getUser, getAllUsers, updateUserName, updateUserEmail, removeUserEmail, logHours, getHoursByUser, getHoursByDateRange, getHoursByUserAndDay, updateHoursForDay, deleteHoursForDay, capitalizeFirstLetter.
   - Keep deleteTestLogs (used by email test utility).
   - Update imports to use @/lib/types.

2. **next/lib/discord/commands.ts** - Create a command dispatcher module:
   - Define a CommandHandler type: `(interaction: APIApplicationCommandInteraction) => Promise<string>` where the string is the response message content.
   - Create a `commands` Map<string, CommandHandler> that maps command names to handlers.
   - For now, register placeholder handlers for all 6 commands (registreer, log, wijzig, verwijder, uren, email) that return "Command not yet implemented".
   - Export a `handleCommand(interaction: APIApplicationCommandInteraction): Promise<Response>` function that:
     a. Extracts command name from interaction.data.name
     b. Looks up handler in commands map
     c. Returns unknown command error if not found
     d. Calls handler and returns ChannelMessageWithSource response with ephemeral flag
   - Use discord-api-types/v10 types (APIApplicationCommandInteraction, InteractionResponseType, MessageFlags).

   IMPORTANT: Discord interactions endpoint must respond within 3 seconds. All existing commands use deferred replies. The handleCommand function should:
   - Return a DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE response immediately
   - Use a fire-and-forget pattern to execute the actual command logic asynchronously
   - The async logic sends the real response via Discord REST API (PATCH to /webhooks/{app_id}/{token}/messages/@original)
   - Import fetch (Node.js built-in) for the REST call
   - The followUp pattern: `fetch(\`https://discord.com/api/v10/webhooks/${appId}/${interaction.token}/messages/@original\`, { method: "PATCH", headers: {"Content-Type": "application/json"}, body: JSON.stringify({content: message, flags: MessageFlags.Ephemeral}) })`

3. **next/app/api/interactions/route.ts** - Update the ApplicationCommand handler:
   - Import handleCommand from @/lib/discord/commands
   - Replace the placeholder "Command received" response with a call to handleCommand(interaction)
   - Keep PING/PONG handling and signature verification unchanged

  </action>
  <verify>cd next && npm run build succeeds. The interactions endpoint compiles and handles command dispatch. Existing PING/PONG still works (do NOT re-register Discord endpoint).</verify>
  <done>Firebase service connected with base64 service account decoding. Command dispatch router working with deferred reply pattern. All 6 command names routed to placeholder handlers. Build passes.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd next && npm run build` succeeds without errors
- [ ] All shared modules exist in next/lib/ with correct @/ imports
- [ ] firebase-admin, date-fns, date-fns-tz, nodemailer installed
- [ ] Firebase service uses base64-decoded service account (not file path)
- [ ] Command dispatch handles deferred reply pattern correctly
- [ ] Interaction endpoint routes ApplicationCommand to handleCommand
- [ ] No TypeScript errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Shared modules ported with correct imports
- Firebase service adapted for Vercel serverless (base64 service account)
- Command dispatch infrastructure ready for Plan 02-02 to implement actual handlers
</success_criteria>

<output>
After completion, create `.planning/phases/02-command-migration/02-01-SUMMARY.md`
</output>
